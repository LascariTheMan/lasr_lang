/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.validation

import dk.sdu.mdsd.lasr_lang.EntityType
import dk.sdu.mdsd.lasr_lang.Intent
import dk.sdu.mdsd.lasr_lang.IntentValue
import dk.sdu.mdsd.lasr_lang.Lasr_langPackage
import dk.sdu.mdsd.lasr_lang.Messages
import dk.sdu.mdsd.lasr_lang.Model
import dk.sdu.mdsd.lasr_lang.Parameter
import dk.sdu.mdsd.lasr_lang.Parameters
import dk.sdu.mdsd.lasr_lang.Prompt
import dk.sdu.mdsd.lasr_lang.Sentence
import dk.sdu.mdsd.lasr_lang.TrainingPhrases
import dk.sdu.mdsd.lasr_lang.Words
import org.eclipse.xtext.validation.Check
import dk.sdu.mdsd.lasr_lang.AbstractIntent
import java.util.ArrayList
import java.util.HashMap

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class Lasr_langValidator extends AbstractLasr_langValidator {
	
	public static val INVALID_NAME = 'invalidName'
	public static val MISSING_AGENT_PARENT = 'missingAgentParent'
	public static val MISSING_AGENT_DISPLAYNAME = 'missingAgentDisplayName'
	public static val MISSING_AGENT_DEFAULTLANGUAGECODE = 'missingAgentDefaultLanguageCode'
	public static val MISSING_AGENT_TIMEZONE = 'missingAgentTimezone'
	public static val MISSING_AGENT_ENABLELOGGING = 'missingAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_PARENT = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_DISPLAYNAME = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_DEFAULTLANGUAGECODE = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_TIMEZONE = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_ENABLELOGGING = 'typeMismatchAgentEnableLogging'
	public static val ONLY_ONE_AGENT_ALLOWED = 'onlyOneAgentInstanceIsAllowed'
	public static val IF_REQUIRED_PARAM_THEN_PROMPT = 'requiredParameterMustContainPrompt'
	public static val PROMPT_STRING_SHOULD_NOT_BE_EMPTY = 'promptStringShouldNotBeEmpty'
	public static val PHRASE_STRING_SHOULD_NOT_BE_EMPTY = 'phraseStringShouldNotBeEmpty'
	public static val INJECTIONS_NOT_FULFILLED = 'injectionsNotFulfilled'
	public static val MESSAGE_STRING_SHOULD_NOT_BE_EMPTY = 'messageStringShouldNotBeEmpty'
	public static val MISSING_INTENT_DISPLAYNAME = 'missingIntentDisplayName'
	public static val DUPLICATE_ENTRY = 'duplicateEntryError'
	public static val IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED = 'missingPhrasesWhenTrainingPhrasesFieldisDef'
	public static val IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT = 'absentTrainingPhrasesOrMessageDefintion'
	
	val toFind = "%"
	val listOfInjections = new HashMap<String, ArrayList<String>>
	val intentExtensions = new ArrayList<String>
	public val lit = Lasr_langPackage.eINSTANCE


	/**
   * Checks if '<em><b>Parameter</b></em>' are required, and if so, that a prompt has been defined.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Parameter}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifRequiredParameterThenPrompts(Parameter param){
		if(param.req == "required" && param.prompts.isEmpty()) {
			error("You must create at least one prompt if the parameter is "+ param.req.toString(),
				null,
				IF_REQUIRED_PARAM_THEN_PROMPT)
		}
	}
	
	/**
   * Checks if '<em><b>TrainingPhrases</b></em>' are defined, and if so, that a phrase has been defined.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.TrainingPhrases}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesDefinedThenPhrasesMustBeDefined(TrainingPhrases tp) {
		if(tp.v !== null && tp.phrases.isEmpty()) {
			error("You must create at least one phrase", null, IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED)
		}
	}
	
	/**
   * Checks if a '<em><b>Prompt</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Prompt}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def promptStringShouldNotBeEmpty(Prompt p) {
		for(Words w : p.words) {			
			if("".equals(w.name)) {
				warning("A prompt should not be empty",
					lit.getPrompt_Words,
					PROMPT_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if a '<em><b>Message</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Messages}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def messageStringShouldNotBeEmpty(Messages m) {
		for(Words w : m.messages) {			
			if("".equals(w.name)) {
				warning("A message should not be empty",
					lit.getMessages_Messages,
					MESSAGE_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if '<em><b>Messages</b></em>' or '<em><b>TrainingPhrases</b></em>' are absent, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesOrMessagesAreAbsent(Intent i) {
		val iVals = newArrayList
		for(var j = 0 ; j < i.values.length ; j++) {
			iVals.add(i.values.get(j).iv.v)
		}
		if(!iVals.contains('trainingPhrases')) {
			warning("This intent won't know much without a few training phrases",
				lit.getIntent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT
			)
		}
		if(!iVals.contains('messages')) {
			warning("This intent won't respond with anything without a few messages",
				lit.getIntent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT
			)
		}
	}
	/*
	@Check
	def ifEntityIsDefinedInPhraseThenDefineInParameter(List l) {
		val pVals = newArrayList
		if(l instanceof Parameters) {
			for(var j = 0 ; j < l.parameters.length ; j++) {
				pVals.add(l.parameters.get(j).name)
				//println(l.parameters.get(j).name)
			}
		}
		if(l instanceof TrainingPhrases) {
			System.out.println("Hej jeg er en phrase")
			var i = 0
			for(Phrase p : l.phrases) {
				println(p.sentences.get(i).entity)
				/*if(!pVals.contains(p.sentences.get(i).entity)) {
					error("You must define the parameter in the parameters clause", lit.getTrainingPhrases_Phrases, "")
				}
				i++
			}
		}
	}
	 */
	 
	 /**
   * Checks if a '<em><b>Phrase</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Sentence}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def phraseStringShouldNotBeEmpty(Sentence s) {
		s.words.filter[it.name.empty].forEach[
			warning("A phrase should not be empty",
					lit.getSentence_Words,
					PHRASE_STRING_SHOULD_NOT_BE_EMPTY
				)
		]
	}
	
	@Check
	def noInjectionsForExtension(AbstractIntent aIntent) {
		listOfInjections.clear
		for (aValue : aIntent.values) {
			if (aValue instanceof Messages) {
				searchForInjections(aValue, aIntent)
			} else if (aValue instanceof TrainingPhrases) {
				searchForInjections(aValue, aIntent)
			}
		}
	}
	
	@Check
	def necessaryInjectionAreAdded(Intent intent) {
		intentExtensions.clear
		val list = listOfInjections.get(intent.toExtend)
		for (injection : intent.injections) {
			intentExtensions.add(injection.key)
			if(!list.contains(injection.key)) {
				warning("Your injections doesn't match with the defined injections in the abstract intent",
					lit.intent_Injections,
					INJECTIONS_NOT_FULFILLED
				)
			}
		}
		for (keyword : list) {
			if(!intentExtensions.contains(keyword)) {
				warning("You are missing some injections for the abstract intent you're extending",
					lit.intent_Injections,
					INJECTIONS_NOT_FULFILLED
				)
			}
		}
	}
	
	def searchForInjections(Messages messages, AbstractIntent aIntent) {
		for (message : messages.messages) {
			addInjection(aIntent, message)
		}
	}
	
	def searchForInjections(TrainingPhrases trainingPhrases, AbstractIntent aIntent) {
		for (phrases : trainingPhrases.phrases) {
			for (sentence : phrases.sentences) {
				for (words : sentence.words) {
					addInjection(aIntent, words)				
				}
			}
		}
	}
	
	def addInjection(AbstractIntent aIntent, Words words) {
		var fromIndex = 0
		while ((fromIndex = words.name.indexOf(toFind, fromIndex)) != -1 ) {
            var endOfWord = words.name.indexOf(" ", fromIndex)
            if (endOfWord === -1) {
				endOfWord = words.name.length
			}
			val injection = words.name.substring(fromIndex+1, endOfWord)
			if (listOfInjections.get(aIntent.name) === null) {
				listOfInjections.put(aIntent.name, new ArrayList)
			}
			val list = listOfInjections.get(aIntent.name)
			list.add(injection)
            fromIndex++
    	}
	}
	
   /**
   * Checks if a '<em><b>Intent</b></em>' has no duplicate entries.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIntentHasOnlyOneOfEachParam(Intent intent) {
		val intentValSet = newHashSet
			for (IntentValue v : intent.values) {
				if(!intentValSet.add(v.iv.v)){
					error("Duplicate entry", v.iv, null, DUPLICATE_ENTRY + " : "+ v.iv)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate intents.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoIntentsWithSameName(Model m) {
		val intentNames = newHashSet
			for (Intent i : m.intents) {
				if(!intentNames.add(i.name)){
					error("Duplicate intent", i, null, DUPLICATE_ENTRY + " : "+ i.name)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate entities.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoEntityWithSameName(Model m) {
		val entityNames = newHashSet
			for (EntityType e : m.entitytypes) {
				if(!entityNames.add(e.name)){
					error("Duplicate entity", e, null, DUPLICATE_ENTRY + " : "+ e.name)
				}
			}
		}
	
	 /**
   * Checks if a '<em><b>Parameters</b></em>' has no duplicate entries.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Parameters}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoParametersWithSameName(Parameters p) {
		val parameterNames = newHashSet
			for (Parameter pm : p.parameters) {
				if(!parameterNames.add(pm.name)){
					error("Duplicate parameter", pm, null, DUPLICATE_ENTRY + " : "+ pm.name)
				}
			}
		}
}