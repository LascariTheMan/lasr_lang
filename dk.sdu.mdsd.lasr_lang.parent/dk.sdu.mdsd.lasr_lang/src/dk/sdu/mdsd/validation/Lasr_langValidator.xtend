/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.validation

import dk.sdu.mdsd.lasr_lang.Agent
import dk.sdu.mdsd.lasr_lang.AgentValue
import dk.sdu.mdsd.lasr_lang.EntityType
import dk.sdu.mdsd.lasr_lang.Intent
import dk.sdu.mdsd.lasr_lang.IntentValue
import dk.sdu.mdsd.lasr_lang.Lasr_langPackage
import dk.sdu.mdsd.lasr_lang.Messages
import dk.sdu.mdsd.lasr_lang.Model
import dk.sdu.mdsd.lasr_lang.Parameter
import dk.sdu.mdsd.lasr_lang.Parameters
import dk.sdu.mdsd.lasr_lang.Prompt
import dk.sdu.mdsd.lasr_lang.Sentence
import dk.sdu.mdsd.lasr_lang.TrainingPhrases
import dk.sdu.mdsd.lasr_lang.Words
import org.eclipse.xtext.validation.Check
import dk.sdu.mdsd.lasr_lang.AbstractIntent
import java.util.ArrayList
import java.util.HashMap

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class Lasr_langValidator extends AbstractLasr_langValidator {
	
	public static val INVALID_NAME = 'invalidName'
	public static val MISSING_AGENT_PARENT = 'missingAgentParent'
	public static val MISSING_AGENT_DISPLAYNAME = 'missingAgentDisplayName'
	public static val MISSING_AGENT_DEFAULTLANGUAGECODE = 'missingAgentDefaultLanguageCode'
	public static val MISSING_AGENT_TIMEZONE = 'missingAgentTimezone'
	public static val MISSING_AGENT_ENABLELOGGING = 'missingAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_PARENT = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_DISPLAYNAME = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_DEFAULTLANGUAGECODE = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_TIMEZONE = 'typeMismatchAgentEnableLogging'
	public static val TYPEMISMATCH_AGENT_ENABLELOGGING = 'typeMismatchAgentEnableLogging'
	public static val ONLY_ONE_AGENT_ALLOWED = 'onlyOneAgentInstanceIsAllowed'
	public static val IF_REQUIRED_PARAM_THEN_PROMPT = 'requiredParameterMustContainPrompt'
	public static val PROMPT_STRING_SHOULD_NOT_BE_EMPTY = 'promptStringShouldNotBeEmpty'
	public static val PHRASE_STRING_SHOULD_NOT_BE_EMPTY = 'phraseStringShouldNotBeEmpty'
	public static val INJECTIONS_NOT_FULFILLED = 'injectionsNotFulfilled'
	public static val MESSAGE_STRING_SHOULD_NOT_BE_EMPTY = 'messageStringShouldNotBeEmpty'
	public static val MISSING_INTENT_DISPLAYNAME = 'missingIntentDisplayName'
	public static val DUPLICATE_ENTRY = 'duplicateEntryError'
	public static val IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED = 'missingPhrasesWhenTrainingPhrasesFieldisDef'
	public static val IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT = 'absentTrainingPhrasesOrMessageDefintion'
	
	val toFind = "%"
	val listOfInjections = new HashMap<String, ArrayList<String>>
	public val lit = Lasr_langPackage.eINSTANCE
	
	/**
   * Checks if any '<em><b>Agent</b></em>' parameters are missing.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.AgentValue}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIfAgentParamsAreMissing(Agent agent) {
		checkAgentParams(agent)
	}
	
	/**
   * Checks if '<em><b>AgentValues</b></em>' parameters are UpperCase.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.AgentValue}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIfAgentParamsAreUpper(AgentValue av) {
		if (!Character.isUpperCase(av.value.v.name.charAt(0))) {
        warning('Agent attributes should start with a capital', av.value.v, 
                lit.getValueName_Name,
                INVALID_NAME)
    	}
	}
	
	/**
   * Checks if '<em><b>AgentValues</b></em>' parameters are allowed, i.e the agent value "parent" =/= boolean.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.AgentValue}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIfAgentParamsAreAllowed(AgentValue agentVal) {
		checkAgentParams(agentVal)
	}
	
	/**
   * Checks if '<em><b>Parameter</b></em>' are required, and if so, that a prompt has been defined.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Parameter}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifRequiredParameterThenPrompts(Parameter param){
		if(param.req == "required" && param.prompts.isEmpty()) {
			error("You must create at least one prompt if the parameter is "+ param.req.toString(),
				null,
				IF_REQUIRED_PARAM_THEN_PROMPT)
		}
	}
	
	/**
   * Checks if '<em><b>TrainingPhrases</b></em>' are defined, and if so, that a phrase has been defined.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.TrainingPhrases}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesDefinedThenPhrasesMustBeDefined(TrainingPhrases tp) {
		if(tp.v !== null && tp.phrases.isEmpty()) {
			error("You must create at least one phrase", null, IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED)
		}
	}
	
	/**
   * Checks if a '<em><b>Prompt</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Prompt}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def promptStringShouldNotBeEmpty(Prompt p) {
		for(Words w : p.words) {			
			if("".equals(w.name)) {
				warning("A prompt should not be empty",
					lit.getPrompt_Words,
					PROMPT_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if a '<em><b>Message</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Messages}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def messageStringShouldNotBeEmpty(Messages m) {
		for(Words w : m.messages) {			
			if("".equals(w.name)) {
				warning("A message should not be empty",
					lit.getMessages_Messages,
					MESSAGE_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if '<em><b>Messages</b></em>' or '<em><b>TrainingPhrases</b></em>' are absent, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesOrMessagesAreAbsent(Intent i) {
		val iVals = newArrayList
		for(var j = 0 ; j < i.values.length ; j++) {
			iVals.add(i.values.get(j).iv.v)
		}
		if(!iVals.contains('trainingPhrases')) {
			warning("This intent won't know much without a few training phrases",
				lit.getIntent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT
			)
		}
		if(!iVals.contains('messages')) {
			warning("This intent won't respond with anything without a few messages",
				lit.getIntent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_OR_MESSAGES_ARE_ABSENT
			)
		}
	}
	/*
	@Check
	def ifEntityIsDefinedInPhraseThenDefineInParameter(List l) {
		val pVals = newArrayList
		if(l instanceof Parameters) {
			for(var j = 0 ; j < l.parameters.length ; j++) {
				pVals.add(l.parameters.get(j).name)
				//println(l.parameters.get(j).name)
			}
		}
		if(l instanceof TrainingPhrases) {
			System.out.println("Hej jeg er en phrase")
			var i = 0
			for(Phrase p : l.phrases) {
				println(p.sentences.get(i).entity)
				/*if(!pVals.contains(p.sentences.get(i).entity)) {
					error("You must define the parameter in the parameters clause", lit.getTrainingPhrases_Phrases, "")
				}
				i++
			}
		}
	}
	 */
	 
	 /**
   * Checks if a '<em><b>Phrase</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Sentence}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def phraseStringShouldNotBeEmpty(Sentence s) {
		for(Words w : s.words) {			
			if("".equals(w.name)) {
				warning("A phrase should not be empty",
					lit.getSentence_Words,
					PHRASE_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	@Check
	def noInjectionsForExtension(AbstractIntent aIntent) {
		listOfInjections.clear
		for (aValue : aIntent.values) {
			if (aValue instanceof Messages) {
				searchForInjections(aValue, aIntent)
			} else if (aValue instanceof TrainingPhrases) {
				searchForInjections(aValue, aIntent)
			}
		}
	}
	
	@Check
	def necessaryInjectionAreAdded(Intent intent) {
		val list = listOfInjections.get(intent.toExtend)
		for (injection : intent.injections) {
			if(!list.contains(injection)) {
				warning("Some injections have not been fulfilled",
					lit.intent_Injections,
					INJECTIONS_NOT_FULFILLED
				)
			}
		}
	}
	
	def searchForInjections(Messages messages, AbstractIntent aIntent) {
		for (message : messages.messages) {
			var fromIndex = 0
			while ((fromIndex = message.name.indexOf(toFind, fromIndex)) != -1 ) {
	            var endOfWord = message.name.indexOf(" ", fromIndex)
	            if (endOfWord === -1) {
					endOfWord = message.name.length
				}
				val injection = message.name.substring(fromIndex+1, endOfWord)
				if (listOfInjections.get(aIntent.name) === null) {
					listOfInjections.put(aIntent.name, new ArrayList)
				}
				val list = listOfInjections.get(aIntent.name)
				list.add(injection)
	            fromIndex++
        	}
		}
	}
	
	def searchForInjections(TrainingPhrases trainingPhrases, AbstractIntent aIntent) {
		for (phrases : trainingPhrases.phrases) {
			for (sentence : phrases.sentences) {
				for (words : sentence.words) {
					var fromIndex = 0
					while ((fromIndex = words.name.indexOf(toFind, fromIndex)) != -1 ) {
			            var endOfWord = words.name.indexOf(" ", fromIndex)
			            if (endOfWord === -1) {
							endOfWord = words.name.length
						}
						val injection = words.name.substring(fromIndex+1, endOfWord)
						if (listOfInjections.get(aIntent.name) === null) {
							listOfInjections.put(aIntent.name, new ArrayList)
						}
						val list = listOfInjections.get(aIntent.name)
						list.add(injection)
			            fromIndex++
		        	}					
				}
			}
		}
	}
	
   /**
   * Checks if a '<em><b>Intent</b></em>' has no duplicate entries.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIntentHasOnlyOneOfEachParam(Intent intent) {
		val intentValSet = newHashSet
			for (IntentValue v : intent.values) {
				if(!intentValSet.add(v.iv.v)){
					error("Duplicate entry", v.iv, null, DUPLICATE_ENTRY + " : "+ v.iv)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate intents.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoIntentsWithSameName(Model m) {
		val intentNames = newHashSet
			for (Intent i : m.intents) {
				if(!intentNames.add(i.name)){
					error("Duplicate intent", i, null, DUPLICATE_ENTRY + " : "+ i.name)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate entities.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoEntityWithSameName(Model m) {
		val entityNames = newHashSet
			for (EntityType e : m.entitytypes) {
				if(!entityNames.add(e.name)){
					error("Duplicate entity", e, null, DUPLICATE_ENTRY + " : "+ e.name)
				}
			}
		}
	
	 /**
   * Checks if a '<em><b>Parameters</b></em>' has no duplicate entries.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Parameters}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoParametersWithSameName(Parameters p) {
		val parameterNames = newHashSet
			for (Parameter pm : p.parameters) {
				if(!parameterNames.add(pm.name)){
					error("Duplicate parameter", pm, null, DUPLICATE_ENTRY + " : "+ pm.name)
				}
			}
		}
	
	 /**
   * Checks if a '<em><b>Agent</b></em>' has no duplicate entries.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Agent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkAgentHasOnlyOneOfEachParam(Agent a) {
		val agentValSet = newHashSet
		for(var i = 0 ; i < a.values.length ; i++) {
			if(!agentValSet.add(a.values.get(i).aa)){
				error("Duplicate entry", a.values.get(i), null, DUPLICATE_ENTRY + " : "+ a.values.get(i))
			}
		}		
	}
	
	 /**
   * Checks if an '<em><b>AgentValue</b></em>' has no type mismatches.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.AgentValue}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	def checkAgentParams(AgentValue agentVal) {
		val bool = agentVal.value.bool
		if(agentVal.value.bool == 'true' || agentVal.value.bool == 'false') {
			if(agentVal.aa == "parent") {
				error('Type mismatch: '+ agentVal.aa + ' cannot be set to ' + bool, 
					lit.getAgentValue_Value,
					TYPEMISMATCH_AGENT_PARENT)
			}
			if(agentVal.aa == "displayName") {
				error('Type mismatch: '+ agentVal.aa + ' cannot be set to ' + bool, 
					lit.getAgentValue_Value,
					TYPEMISMATCH_AGENT_DISPLAYNAME)
			}
			if(agentVal.aa == "defaultLanguageCode") {
				error('Type mismatch: '+ agentVal.aa + ' cannot be set to ' + bool, 
					lit.getAgentValue_Value,
					TYPEMISMATCH_AGENT_DEFAULTLANGUAGECODE)
			}
			if(agentVal.aa == "timezone") {
				error('Type mismatch: '+ agentVal.aa + ' cannot be set to ' + bool, 
					lit.getAgentValue_Value,
					TYPEMISMATCH_AGENT_TIMEZONE)
			}
			if(agentVal.aa == "enableLogging" && (agentVal.value.v.name !== 'true' || agentVal.value.v.name !== 'false')) {
				error('Type mismatch:  '+ agentVal.aa + ' cannot be set to ' +agentVal.value.v.name.class.typeName, 
					lit.getAgentValue_Value,
					TYPEMISMATCH_AGENT_ENABLELOGGING)
			}	
		}
		
	}
	
	 /**
   * Checks if an '<em><b>Agent</b></em>' has no missing parameters.
   * The parameters are of type {@link dk.sdu.mdsd.lasr_lang.Agent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	def checkAgentParams(Agent agent) {
		val agentValues = newArrayList
		for(AgentValue v : agent.values) {
			agentValues.add(v.aa)
		}
		
		if (!agentValues.contains('parent')) {
			error('You must define the parent variable', 
					null,
					MISSING_AGENT_PARENT)
		} else if (!agentValues.contains('displayName')) {
			error('You must define the displayName variable', 
					null,
					MISSING_AGENT_DISPLAYNAME)
		} else if (!agentValues.contains('defaultLanguageCode')) {
			error('You must define the defaultLanguageCode variable', 
					null,
					MISSING_AGENT_DEFAULTLANGUAGECODE)
		} else if (!agentValues.contains('timezone')) {
			error('You must define the timezone variable', 
					null,
					MISSING_AGENT_TIMEZONE)
		} else if (!agentValues.contains('enableLogging')) {
			error('You must define the enableLogging variable', 
					null,
					MISSING_AGENT_ENABLELOGGING)
		}
	}
}