/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.validation

import dk.sdu.mdsd.lasr_lang.Agent
import dk.sdu.mdsd.lasr_lang.AgentValue
import dk.sdu.mdsd.lasr_lang.Intent
import dk.sdu.mdsd.lasr_lang.Lasr_langPackage
import dk.sdu.mdsd.lasr_lang.Messages
import dk.sdu.mdsd.lasr_lang.Model
import dk.sdu.mdsd.lasr_lang.Parameter
import dk.sdu.mdsd.lasr_lang.Parameters
import dk.sdu.mdsd.lasr_lang.Prompt
import dk.sdu.mdsd.lasr_lang.Sentence
import dk.sdu.mdsd.lasr_lang.TrainingPhrases
import dk.sdu.mdsd.lasr_lang.VirtualIntent
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class Lasr_langValidator extends AbstractLasr_langValidator {
	
	public static val IF_REQUIRED_PARAM_THEN_PROMPT = 'requiredParameterMustContainPrompt'
	public static val PROMPT_STRING_SHOULD_NOT_BE_EMPTY = 'promptStringShouldNotBeEmpty'
	public static val PHRASE_STRING_SHOULD_NOT_BE_EMPTY = 'phraseStringShouldNotBeEmpty'
	public static val MESSAGE_STRING_SHOULD_NOT_BE_EMPTY = 'messageStringShouldNotBeEmpty'
	public static val DUPLICATE_INTENT = 'duplicateIntent'
	public static val DUPLICATE_INTENT_PARAMS = 'duplicateIntentParams'
	public static val DUPLICATE_ENTITY = 'duplicateEntity'
	public static val DUPLICATE_PARAMETER = 'duplicateParameter'
	public static val DUPLICATE_AGENT_PARAMS = 'duplicateAgent'
	public static val IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED = 'missingPhrasesWhenTrainingPhrasesFieldisDef'
	public static val IF_TRAINING_PHRASES_ARE_ABSENT = 'absentTrainingPhrasesDefintion'
	public static val IF_MESSAGES_ARE_ABSENT = 'absentMessageDefintion'
	
	public val lit = Lasr_langPackage.eINSTANCE
	
	
	/**
   * Checks if '<em><b>Parameter</b></em>' are required, and if so, that a prompt has been defined.
   * The parameters are of type {@link Parameter}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifRequiredParameterThenPrompts(Parameter param){
		if(param.req == "required" && param.prompts.isEmpty()) {
			error("You must create at least one prompt if the parameter is "+ param.req.toString(),
				null, IF_REQUIRED_PARAM_THEN_PROMPT)
		}
	}
	
	/**
   * Checks if '<em><b>TrainingPhrases</b></em>' are defined, and if so, that a phrase has been defined.
   * The parameters are of type {@link TrainingPhrases}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesDefinedThenPhrasesMustBeDefined(TrainingPhrases tp) {
		if(tp.v !== null && tp.phrases.isEmpty()) {
			error("You must create at least one phrase", null, IF_TRAINING_PHRASE_DEFINED_THEN_PHRASES_MUST_BE_DEFINED)
		}
	}
	
	/**
   * Checks if a '<em><b>Prompt</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link Prompt}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def promptStringShouldNotBeEmpty(Prompt p) {
		for(words : p.words) {			
			if("".equals(words.name)) {
				warning("A prompt should not be empty",
					lit.getPrompt_Words,
					PROMPT_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if a '<em><b>Message</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link Messages}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def messageStringShouldNotBeEmpty(Messages m) {
		for(words : m.messages) {			
			if("".equals(words.name)) {
				warning("A message should not be empty",
					lit.getMessages_Messages,
					MESSAGE_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
	/**
   * Checks if '<em><b>TrainingPhrases</b></em>' are absent in the defined '<em><b>Intent</b></em>'.
   * The parameter is of type {@link Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifTrainingPhrasesAreAbsent(Intent i) {
		val iVals = newArrayList
		if(i.vi === null) { 
			for(var j = 0 ; j < i.values.length ; j++) {
				iVals.add(i.values.get(j).iv.v)
			}
			if(!iVals.contains('trainingPhrases')) {
				warning("This intent won't know much without a few training phrases",
					i, lit.intent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_ARE_ABSENT
				)
			}
		}
	}
	
	/**
   * Checks if '<em><b>Messages</b></em>' are absent in the defined '<em><b>Intent</b></em>'.
   * The parameter is of type {@link Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifMessagesAreAbsent(Intent i) {
		val iVals = newArrayList
		for (vi : i.vi) {
			if(i.vi === null) { 
				for(var j = 0 ; j < i.values.length ; j++) {
					iVals.add(i.values.get(j).iv.v)
				}
				if(!iVals.contains('messages')) {
					warning("This intent won't respond with anything without a few messages",
						i, lit.intent_Name, Lasr_langValidator.IF_MESSAGES_ARE_ABSENT
					)
				}
			}
		}
	}
	
	/**
   * Checks if '<em><b>TrainingPhrases</b></em>' are absent in the defined '<em><b>VirtualIntent</b></em>'.
   * The parameter is of type {@link VirtualIntent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifVirtualTrainingPhrasesAreAbsent(VirtualIntent i) {
		val iVals = newArrayList
			for(var j = 0 ; j < i.virtualValues.length ; j++) {
				iVals.add(i.virtualValues.get(j).v)
			}
		if(!iVals.contains('trainingPhrases')) {
			warning("This intent won't know much without a few training phrases",
				lit.getVirtualIntent_Name, Lasr_langValidator.IF_TRAINING_PHRASES_ARE_ABSENT
			)
		}
	}
	
	/**
   * Checks if '<em><b>Messages</b></em>' are absent in the defined '<em><b>VirtualIntent</b></em>'.
   * The parameter is of type {@link VirtualIntent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def ifVirtualMessagesAreAbsent(VirtualIntent i) {
		val iVals = newArrayList
		for(var j = 0 ; j < i.virtualValues.length ; j++) {
			iVals.add(i.virtualValues.get(j).v)
		}
		if(!iVals.contains('messages')) {
			warning("This intent won't respond with anything without a few messages",
				lit.getVirtualIntent_Name, Lasr_langValidator.IF_MESSAGES_ARE_ABSENT
				)
		}
	}

	 
	 /**
   * Checks if a '<em><b>Phrase</b></em>' is empty, and if so, gives a warning.
   * The parameters are of type {@link Sentence}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def phraseStringShouldNotBeEmpty(Sentence s) {
		for(w : s.words) {			
			if("".equals(w.name)) {
				warning("A phrase should not be empty",
					lit.getSentence_Words,
					PHRASE_STRING_SHOULD_NOT_BE_EMPTY
				)
			}
		}
	}
	
   /**
   * Checks if a '<em><b>Intent</b></em>' has no duplicate entries.
   * The parameters are of type {@link Intent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkIntentHasOnlyOneOfEachParam(Intent intent) {
		val intentValSet = newHashSet
			for (v : intent.values) {
				if(!intentValSet.add(v.iv.v)){
					error("Duplicate intent entry", v, null, DUPLICATE_INTENT_PARAMS)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate intents.
   * The parameters are of type {@link Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoIntentsWithSameName(Model m) {
		val intentNames = newHashSet
			for (i : m.intents) {
				if(!intentNames.add(i.name)){
					error("Duplicate intent", i, null, DUPLICATE_INTENT)
				}
			}
		}		
	
	 /**
   * Checks if the '<em><b>Model</b></em>' has no duplicate entities.
   * The parameters are of type {@link Model}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoEntityWithSameName(Model m) {
		val entityNames = newHashSet
			for (e : m.entitytypes) {
				if(!entityNames.add(e.name)){
					error("Duplicate entity", e, null, DUPLICATE_ENTITY)
				}
			}
		}
	
	 /**
   * Checks if a '<em><b>Parameters</b></em>' has no duplicate entries.
   * The parameters are of type {@link Parameters}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkNoParametersWithSameName(Parameters p) {
		val parameterNames = newHashSet
			for (pm : p.parameters) {
				if(!parameterNames.add(pm.name)){
					error("Duplicate parameter", pm, null, DUPLICATE_PARAMETER)
				}
			}
		}
	
	 /**
   * Checks if a '<em><b>Agent</b></em>' has no duplicate entries.
   * The parameters are of type {@link Agent}.
   * <!-- begin-user-doc -->
   * <p>
   * 
   * </p>
   * <!-- end-user-doc -->
   */
	@Check
	def checkAgentHasOnlyOneOfEachParam(Agent a) {
		val agentValSet = newHashSet
		for(var i = 0 ; i < a.values.length ; i++) {
			if(!agentValSet.add(a.values.get(i).aa)){
				error("Duplicate entry", a.values.get(i), null, DUPLICATE_AGENT_PARAMS)
			}
		}		
	}
	
}